<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++内存布局</title>
    <url>/C-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<h3 id="1-内存分布图"><a href="#1-内存分布图" class="headerlink" title="1. 内存分布图"></a>1. 内存分布图</h3><p><img src="https://pic.imgdb.cn/item/5f729e85160a154a675a2493.png" alt="Memory Sort Map"></p>
<a id="more"></a>
<p><font color=green size=4>1. Stack段：局部变量存放区域。</font><br><font color=green size=4>2. heap段：用户动态分配内存区域。</font><br><font color=green size=4>3. bss段：存放未初始化的全局或静态变量内存区域。(Block Started by Symbol)</font><br><font color=green size=4>4. 数据段：通常指存放已初始化的全局变量的内存区域。(data segment)</font><br><font color=green size=4>5. 代码段：通常指存放程序执行代码的一块内存区域。(code segment/text segment)</font></p>
<blockquote>
<p>C规定，未初始化变量的初值为0，这个清0的操作是由<strong>启动代码</strong>完成的，还有已初始化变量的初值的设置，也是由<strong>启动代码</strong>完成的。<br>为了启动代码的简单化，编译链接器会把已初始化的变量放在同一个段：.data，这个段的映像（包含了各个变量的初值）保存在“只读数据段”，这样启动代码就可以简单地复制这个映像到 .data 段，所有的已初始化变量就都初始化了。<br>而未初始化变量也放在同一个段：.bss，启动代码简单地调用 memset 就可以把所有未初始化变量都清0。</p>
</blockquote>
<hr>
<h3 id="2-在C中分为5个存储区"><a href="#2-在C中分为5个存储区" class="headerlink" title="2. 在C中分为5个存储区"></a>2. 在C中分为5个存储区</h3><p><font color=green size=4>1. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似数据结构中的栈。</font><br><font color=green size=4>2. 堆区:一般由程序员分配和释放(malloc,alloc,realloc,free)，程序结束时内存空间由系统回收，与数据结构的堆毫无关系。</font><br><font color=green size=4>3. 全局/静态区：全局变量和静态变量的存储是在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</font><br><font color=green size=4>4. 文字常量区：常量和字符串就是存放在这里，程序结束后由系统释放。</font><br><font color=green size=4>5. 程序代码区：存放函数体的二进制代码。</font></p>
<blockquote>
<p>所有函数体外定义的变量就是全局变量，加了static修饰符后不管在哪里都存放在全局（静态区），全局的static变量只对该文件中有效，不能extern到别的文件用，在函数体内部定义的static表示在该函数体内有效。另外，函数体中的这样的字符串字面量存放在常量区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span>* p ;<span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//s在栈，abc在字符常量区</span></span><br><span class="line">	<span class="keyword">char</span> *p2 ;<span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p3 = <span class="string">&quot;abcdef&quot;</span><span class="comment">//p3栈，abcdef在字符常量区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">	p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//在堆上开辟10个字节的内存，p1本身在栈中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-C-C-中堆区和自由存储区的区别与联系"><a href="#3-C-C-中堆区和自由存储区的区别与联系" class="headerlink" title="3. C/C++中堆区和自由存储区的区别与联系"></a>3. C/C++中堆区和自由存储区的区别与联系</h3><p><font color=green size=4>1. malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放。</font><br><font color=green size=4>2. 堆(heap)是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存释放。自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，即缺省的全局运算符new和delete会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</font></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言套接字编程</title>
    <url>/C%E8%AF%AD%E8%A8%80%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>Socket</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C测试框架</title>
    <url>/C%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<p>cmake:     3.13.4<br>g++:       8.3.0 (Raspbian 8.3.0-6+rpi1)<br>CXX_STD:c++11</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:code $ mkdir testFrame &amp;&amp; git <span class="built_in">clone</span> https://github.com/google/googletest.git</span><br><span class="line">pi@raspberrypi:code $ <span class="built_in">cd</span> googletest &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">pi@raspberrypi:build $ cmake ../	<span class="comment">#省略cmake输出</span></span><br><span class="line">pi@raspberrypi:build $ make		<span class="comment">#略make输出，如有报错，尝试在CMakelist.txt增加SET(CMAKE_CXX_FLAGS &quot;-std=c++0x&quot;)</span></span><br><span class="line">pi@raspberrypi:build $ cp lib ../../testFrame/ -r</span><br><span class="line">pi@raspberrypi:build $ cp ../googletest/include/ ../../testFrame/ -r</span><br><span class="line">pi@raspberrypi:build $ <span class="built_in">cd</span> ../../testFrame/</span><br><span class="line">pi@raspberrypi:testFrame $ vim main.cpp	<span class="comment">#main.cpp源码单独放在一个代码块里</span></span><br><span class="line">pi@raspberrypi:testFrame $ g++ -I./include -L./lib -o main main.cpp -lgtest -lpthread</span><br><span class="line">pi@raspberrypi:testFrame $ ./main </span><br><span class="line">hello world</span><br><span class="line">add(3, 4) = 7</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from <span class="built_in">test</span></span><br><span class="line">[ RUN      ] test.add1</span><br><span class="line">[       OK ] test.add1 (0 ms)</span><br><span class="line">[ RUN      ] test.add2</span><br><span class="line">main.cpp:21: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  add(3, 4)</span><br><span class="line">    Which is: 7</span><br><span class="line">  6</span><br><span class="line">[  FAILED  ] test.add2 (0 ms)</span><br><span class="line">[----------] 2 tests from <span class="built_in">test</span> (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] test.add2</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTICE - DO NOT IGNORE:</span><br><span class="line">This <span class="built_in">test</span> program did NOT call testing::InitGoogleTest() before calling RUN_ALL_TESTS(). This is INVALID. Soon Google Test will start to enforce the valid usage. Please fix it ASAP, or IT WILL START TO FAIL.</span><br></pre></td></tr></table></figure>
<p>tttttt</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(test, add1) &#123;</span><br><span class="line">	EXPECT_EQ(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_NE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_LT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>);</span><br><span class="line">	EXPECT_LE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_GT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_GE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(test, add2) &#123;</span><br><span class="line">	EXPECT_EQ(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_NE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_LT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>);</span><br><span class="line">	EXPECT_LE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_GT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_GE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;add(3, 4) = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>


]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>gtest</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake编写规则</title>
    <url>/CMake%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99.html</url>
    <content><![CDATA[<h3 id="cmake预定义变量"><a href="#cmake预定义变量" class="headerlink" title="cmake预定义变量"></a>cmake预定义变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT_NAME #通过PROJECt指令定义的项目名称</span><br><span class="line"></span><br><span class="line">PROJECT_SOURCE_DIR #cmake命令后紧跟的目录, 一般是工程的根目录</span><br><span class="line"></span><br><span class="line">PROJECT_BINARY_DIR #执行cmake命令的目录, 通常是$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;build</span><br></pre></td></tr></table></figure>

<h3 id="cmake语法"><a href="#cmake语法" class="headerlink" title="cmake语法"></a>cmake语法</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置cmake版本</span></span><br><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置工程名称</span></span><br><span class="line">project(hello_world)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#添加头文件路径, 对应gcc -I和添加到环境变量CPLUS_INCLUDE_PATH</span></span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加链接库路径, 对应gcc -L和添加到环境变量LD_LIBRARY_PATH</span></span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 module 子目录, 此目录下也应当存在一个CMakeLists.txt文件</span></span><br><span class="line">add_subdirectory(module)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加预处理宏定义</span></span><br><span class="line">add_definitions(-DDEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件路径</span></span><br><span class="line"><span class="comment">#添加编译器检测支持</span></span><br><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line"><span class="comment">#检查C11标准支持, 结果放到变量COMPILER_SUPPORTS_CXX11里</span></span><br><span class="line">CHECK_CXX_COMPILER_FLAG(<span class="string">&quot;-std=c++11&quot;</span> COMPILER_SUPPORTS_CXX11)</span><br><span class="line">if(COMPILER_SUPPORTS_CXX11)</span><br><span class="line"><span class="comment">#添加c++11编译选项</span></span><br><span class="line">    add_compile_options(-std=c++11) </span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加编译选项</span></span><br><span class="line">add_compile_options(-g -Wall  -Werror) </span><br><span class="line"></span><br><span class="line"><span class="comment">#动态库的添加</span></span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib) <span class="comment">#添加动态连接库的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置可执行文件的输出目录</span></span><br><span class="line">SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/../bin)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译为执行文件 (源文件 依赖文件...)</span></span><br><span class="line">add_executable(hello $&#123;DIR_SRCS&#125;)</span><br><span class="line">target_link_libraries(hello -lmodule) <span class="comment">#添加libmodule.so</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#module子目录下的CMakeLists.txt</span></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置库文件的输出目录</span></span><br><span class="line">SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/../lib) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态链接库</span></span><br><span class="line">add_library(module share $&#123;DIR_LIB_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态链接库</span></span><br><span class="line">add_library(module staitc $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译过程</title>
    <url>/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h3 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h3><hr>
<p><img src="https://pic.imgdb.cn/item/5f73f793160a154a67b421a5.jpg" alt="C程序编译过程"></p>
<a id="more"></a>
<p>GCC编译一个C/C++ 程序到可执行程序可分成以上4个步骤。例如，”gcc-o hello.exe hello.c”执行如下:</p>
<h6 id="1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。"><a href="#1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。" class="headerlink" title="1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。"></a>1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp hello.c &gt; hello.i</span></span><br></pre></td></tr></table></figure>
<p>生成的文件”hello.i”包含了展开扩展后的源码。</p>
<h6 id="2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。"><a href="#2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。" class="headerlink" title="2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。"></a>2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i</span></span><br></pre></td></tr></table></figure>
<p>选项 -S 指定生成汇编代码，而不是目标代码。生成的汇编文件为”hello.s”。</p>
<h6 id="3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。"><a href="#3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。" class="headerlink" title="3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。"></a>3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s</span></span><br></pre></td></tr></table></figure>

<h6 id="4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。"><a href="#4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。" class="headerlink" title="4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。"></a>4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello.exe hello.o ...libraries...</span></span><br></pre></td></tr></table></figure>

<p>Verbose Mode (-v)<br>可以通过启用-v (verbose)选项查看详细的编译过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br></pre></td></tr></table></figure>

<p>Defining Macro (-D)<br>可以使用-Dname选项定义宏，或者使用-Dname=value定义带有值的宏。如果值包含空格，则应该用双引号括起来。</p>
<h3 id="头文件-h-，静态库-a-lib-和动态库-so-dll"><a href="#头文件-h-，静态库-a-lib-和动态库-so-dll" class="headerlink" title="头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)"></a>头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)</h3><hr>
<h5 id="静态库-VS-动态库"><a href="#静态库-VS-动态库" class="headerlink" title="静态库 VS 动态库"></a>静态库 VS 动态库</h5><p>库是可以通过链接器链接到程序中的预编译过的目标文件的集合，例如系统函数printf()和sqrt()。<br><br>外部库有两种类型:静态库和共享库。<br></p>
<ol>
<li>静态库的文件扩展名在Unix中为”.a”(归档文件)在Windows中为”.lib”。当链接静态库到程序时，程序中使用的外部函数的机器码将复制到可执行文件中。静态库可以通过”ar”存档程序创建。<br></li>
<li>共享库的文件扩展名在Unix中为”.lib”(共享对象)在Windows中为”dll”(动态链接库)。当链接共享库到程序时，只会在可执行文件中创建一个小表。在可执行文件开始运行之前，操作系统加载外部函数所需的机器码——这个过程称为动态链接。动态链接使可执行文件更小并节省磁盘空间，因为库的一个副本可以在多个程序之间共享。此外，大多数操作系统允许内存中共享库的一个副本被所有正在运行的程序使用，从而节省内存。可以升级共享库代码，而不需要重新编译程序。</li>
</ol>
<p>由于动态链接的优点，默认情况下，如果共享库可用，GCC会链接到共享库。<br><br>您可以通过 <font color=red>nm file</font> 列出库的内容。</p>
<h5 id="搜索头文件和库-I-L-and-l"><a href="#搜索头文件和库-I-L-and-l" class="headerlink" title="搜索头文件和库(-I, -L and -l)"></a>搜索头文件和库(-I, -L and -l)</h5><p>在编译程序时，编译器需要头文件来编译源代码;链接器需要这些库来解析来自其他对象文件或库的外部引用。除非您设置了适当的选项，否则编译器和链接器将无法找到头文件/库。<br><br>对于源代码中使用的每个头文件(通过#include指令)，编译器会搜索这些头文件的包含路径。包含路径是通过-I&lt;dir&gt;选项(或环境变量CPATH)指定的。因为头文件的文件名是已知的(例如iostream)。，编译器只需要目录。<br><br>链接器在库路径中搜索将可执行文件所需链接到的库。库路径是通过-Ldir选项(大写’L’后跟目录路径)(或环境变量LIBRARY_PATH)指定的。此外，还必须指定库名。在Unix中，库libxxx.a是通过-lxxx选项(小写字母’l’，没有前缀”lib”和”.so”扩展)。在Windows中，提供全名，如-lxxx.lib。链接器需要知道目录和库的名称。因此，需要指定两个选项。</p>
<h5 id="默认的头文件路径，库路径和库"><a href="#默认的头文件路径，库路径和库" class="headerlink" title="默认的头文件路径，库路径和库"></a>默认的头文件路径，库路径和库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp -v</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>以详细模式(-v)运行编译，学习使用系统中使用的库路径(-L)和库(-L):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br><span class="line">......</span><br><span class="line">-L/usr/lib/gcc/x86_64-pc-cygwin/6.4.0</span><br><span class="line">-L/usr/x86_64-pc-cygwin/lib</span><br><span class="line">-L/usr/lib</span><br><span class="line">-L/lib</span><br><span class="line">-lgcc_s     // libgcc_s.a</span><br><span class="line">-lgcc       // libgcc.a</span><br><span class="line">-lcygwin    // libcygwin.a</span><br><span class="line">-ladvapi32  // libadvapi32.a</span><br><span class="line">-lshell32   // libshell32.a</span><br><span class="line">-luser32    // libuser32.a</span><br><span class="line">-lkernel32  // libkernel32.a</span><br></pre></td></tr></table></figure>

<h3 id="GCC-环境变量"><a href="#GCC-环境变量" class="headerlink" title="GCC 环境变量"></a>GCC 环境变量</h3><p>GCC使用下面这些环境变量:</p>
<ul>
<li>PATH: 用于搜索可执行程序和运行时共享库(.so, .dll)。</li>
<li>CPATH: 用于搜索头文件的包含路径。它在-I<dir>选项中指定的路径被搜索后搜索。如果在预处理中指定了特定的语言，那么<em>C_INCLUDE_PATH</em>和<em>CPLUS_INCLUDE_PATH</em>可以用来指定C和C++头文件。</li>
<li>LIBRARY_PATH: 用于搜索链接库的库路径。。它在-L<dir>选项中指定的路径被搜索后搜索。</li>
</ul>
<h3 id="编译过程实操"><a href="#编译过程实操" class="headerlink" title="编译过程实操"></a>编译过程实操</h3><blockquote>
<p>file #显示文件类型<br></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL(x, y) ((x)*(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	z = add(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, add(x, y));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, MUL(x, y));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash">cpp hello.c &gt; hello.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpp add.c &gt; add.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.i</span></span><br><span class="line">...//此处省略若干行</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 <span class="string">&quot;hello.c&quot;</span></span></span><br><span class="line">int add(int, int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"> int x = 3, y = 4;</span><br><span class="line"> printf(&quot;%d + %d = %d\n&quot;, x, y, add(x, y));</span><br><span class="line"> printf(&quot;%d * %d = %d\n&quot;, x, y, ((x)*(y)));</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#可以看出MUL宏被展开了</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S add.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.s </span></span><br><span class="line">hello.s: assembler source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.s </span></span><br><span class="line">	.file	&quot;hello.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;%d + %d = %d\n&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string	&quot;%d * %d = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">...//此处省略若干行，展开后的源码在这一步被编译成对应平台的汇编代码</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o add.o add.s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.o </span></span><br><span class="line">hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 0000000000400280</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#上面这个警告不会影响程序运行，但是会在return的时候导致段错误</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello</span></span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ./hello </span></span><br><span class="line">3 + 4 = 7</span><br><span class="line">3 * 4 = 12</span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#ld那一步的警告改用gcc命令可以避免&lt;br&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nm   #通常用于检查对象文件中是否定义了特定的函数。”T”表示已定义的函数，”U”表示未定义的函数，应由链接器解析。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nm -C hello.o </span></span><br><span class="line">                 U add      #可以看到目标文件hello.o里没有add函数的定义 </span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U printf</span><br><span class="line"><span class="meta">#</span><span class="bash"> nm add.o </span></span><br><span class="line">0000000000000000 T add      #add的定义在目标文件add.o中</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nm    #用来显示它所需要的共享库的列表。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd hello</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe8c1f0000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3d1b6bd000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f3d1ba87000)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接 <a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本操作指北</title>
    <url>/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8C%97.html</url>
    <content><![CDATA[<h3 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成密钥 -t 指定加密方式 -C 为密钥注释</span></span><br><span class="line">Mars@company MINGW64 ~</span><br><span class="line">$ ssh-keygen.exe -t rsa -C <span class="string">&quot;huahua&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Mars/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> ./huahua</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> ./huahua.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:rVborm7Xt7FhEmrmKbkaSA8WLsP0d4svizcCBOacsWE huahua</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|.E               |</span></span><br><span class="line"><span class="string">|*.*              |</span></span><br><span class="line"><span class="string">|oB..     o       |</span></span><br><span class="line"><span class="string">|+.=. . .S +      |</span></span><br><span class="line"><span class="string">| * +. o..+ .     |</span></span><br><span class="line"><span class="string">|  o o. oB.. +    |</span></span><br><span class="line"><span class="string">|   ..==*...o.+   |</span></span><br><span class="line"><span class="string">|   .+=B*+  .o.   |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 把公钥内容(id_rsa.pub)添加到github个人设置页SSH and GPG keys里</span></span><br><span class="line"><span class="string">Mars@company MINGW64 ~</span></span><br><span class="line"><span class="string">$ cat id_rsa.pub</span></span><br><span class="line"><span class="string">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDcmn0i3Lt+EN3bf879l7Mb5zscFeQN4lH4Qj9qOS0lXNsVnT0RfqqD3QDUO03bEzzWWiNgjnTGZj7QPYHB7c3PQZhT5tPidWyYfR22EbtKfNysXvuDRvjuu/jzl2QFYGfI3IWbGj2H9pr6PScxYfAqxHJ6ZBqLtBjdBsdVT5pY28Cut29Yf06NCbSpb8AyUY5RZpeDZcnpVeADkoA0hUP8J7ny1T+2X7RpAjLvdfpGU0yPkEsata4MuwcliweW17fgM6vcqsN7OOMNYjCiWafl444x1dhfNwueJelXSL/4mNG5q7d5NxS3jRlxsA6JtPe/27DohQs2pKH44K+86tC9jSWTRJH5HGU7rDS7xV3Jipr9VSFpyqin5DQckJlVCggN1yOLXUITgeiT+1wO6ejrcKV1bq1EtaeuyQ7/Kopk/cdIloLQpS6VK2c9ftvIzNaSQz8w+MXL26I/fI8ZF3/LLHzcfCJeQkUKO7Ev2GxbTh3cG397+sEKYsq+ASGLbaE= huahua</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置提交代码时使用的名字和邮箱</span></span><br><span class="line"><span class="string">Mars@company MINGW64 ~</span></span><br><span class="line"><span class="string">$ git config --global user.name &quot;marjosong&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Mars@company MINGW64 ~</span></span><br><span class="line"><span class="string">$ git config --global user.email  &quot;769200142@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="本地初始化仓库并推送至远程"><a href="#本地初始化仓库并推送至远程" class="headerlink" title="本地初始化仓库并推送至远程"></a>本地初始化仓库并推送至远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos</span><br><span class="line">$ git init      </span><br><span class="line">Reinitialized existing Git repository <span class="keyword">in</span> D:/git/C-Demos/.git/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到仓库</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git add .     </span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> select/CMakeLists.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交修改</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git commit -m <span class="string">&quot;init project&quot;</span>  </span><br><span class="line">[master e919c88] init project</span><br><span class="line"> 52 files changed, 535 insertions(+), 2147 deletions(-)</span><br><span class="line"> ...  <span class="comment">#此处省略若干行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地仓库添加到远程仓库(这里故意犯了个错误)</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git remote add origin https://github.com/MarJoSong/C-Demos.git    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制提交本地代码到远程仓库(会删除原来仓库里面的文件)</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git push -u origin master -f</span><br></pre></td></tr></table></figure>

<h3 id="修改远程仓库的地址"><a href="#修改远程仓库的地址" class="headerlink" title="修改远程仓库的地址"></a>修改远程仓库的地址</h3><p>上一步的的添加的远程仓库是https的形式，会导致每次推送代码都需要输入账号密码，现在来解决这个问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/MarJoSong/C-Demos.git (fetch)</span><br><span class="line">origin  https://github.com/MarJoSong/C-Demos.git (push)</span><br><span class="line"></span><br><span class="line">Mars@company MINGW64 /e/C-Demos (master)</span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line">Mars@company MINGW64 /e/C-Demos (master)</span><br><span class="line">$ git remote add origin git@github.com:MarJoSong/C-Demos.git</span><br><span class="line"></span><br><span class="line">Mars@company MINGW64 /e/C-Demos (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:MarJoSong/C-Demos.git (fetch)</span><br><span class="line">origin  git@github.com:MarJoSong/C-Demos.git (push)</span><br></pre></td></tr></table></figure>

<h3 id="为每一个项目建立-gitignore"><a href="#为每一个项目建立-gitignore" class="headerlink" title="为每一个项目建立.gitignore"></a>为每一个项目建立.gitignore</h3><p>在我们编译调试代码的时候会生成很多非必要的文件，通过.gitignore避免对这些文件的状态跟踪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在项目根目录建立.gitgnore文件，编写规则百度</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ cat .gitignore</span><br><span class="line"><span class="comment">#不跟踪项目根路径下面的第一级目录下的以cmake-build-开头的文件夹及里面的文件</span></span><br><span class="line">/*/cmake-build-*/   </span><br><span class="line"><span class="comment">#不跟踪项目根路径下面的第一级目录下的.idea文件夹及里面的文件</span></span><br><span class="line">/*/.idea/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件移出版本控制</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git rm -r --cached .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件到版本控制(使用.gitgnore规则)</span></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git commit -m <span class="string">&quot;update .gitignore&quot;</span></span><br><span class="line"></span><br><span class="line">Mars@company MINGW64 /d/git/C-Demos (master)</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH密钥登录二三事</title>
    <url>/SSH%E7%99%BB%E5%BD%95%E4%BA%8C%E4%B8%89%E4%BA%8B.html</url>
    <content><![CDATA[<p>在日常使用中，除了密码登录更多的是使用密钥方式登录SSH。密钥对分成公钥和私钥，将公钥添加到需要登录的服务器用户的家目录下.ssh/authorized_keys文件中，在ssh登录时使用’-i’参数指定私钥 或 将私钥天骄到Xshell用户密钥中。</p>
<p>使用密钥登录通常需要经过以下步骤：</br></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 客户端软件：Xshell 6</br></li>
<li><input checked="" disabled="" type="checkbox"> 客户端终端：Linux company 4.4.0-18362-Microsoft</br></li>
<li><input checked="" disabled="" type="checkbox"> 服务端版本：OpenSSH_7.9p1 Raspbian-10+deb10u2, OpenSSL 1.1.1d  10 Sep 2019</li>
</ul>
<h3 id="生成登录密钥对"><a href="#生成登录密钥对" class="headerlink" title="生成登录密钥对"></a>生成登录密钥对</h3><ul>
<li>方法一：使用ssh-keygen命令生成密钥对</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t 加密方式 -C 备注</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~$ ssh-keygen -t rsa #加密方式为rsa</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa): &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars #置空使用默认路径和命名</span><br><span class="line">Enter passphrase (empty for no passphrase): #置空表示不为密钥设置密码</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Y11r6HcjCAK35&#x2F;6N0ry1e7aEeQoIdhfws1F02YmpNl4 mars@company</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|        .  .o +o.|</span><br><span class="line">|         o . +...|</span><br><span class="line">|    . .   &#x3D; o    |</span><br><span class="line">|     o . . @ E   |</span><br><span class="line">|      &#x3D; S B &#x3D;    |</span><br><span class="line">|     . B * + o   |</span><br><span class="line">|        oo+ * &#x3D;  |</span><br><span class="line">|       .. o* Bo. |</span><br><span class="line">|        .o+.&#x3D;+.. |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line">mars@company:~$ cd .ssh&#x2F; &amp;&amp; ll</span><br><span class="line">total 8.0K</span><br><span class="line">-rw------- 1 mars mars 2.6K Oct 26 15:22 id_rsa_mars #私钥的权限必须为0600</span><br><span class="line">-rw-r--r-- 1 mars mars  566 Oct 26 15:22 id_rsa_mars.pub</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Xshell客户端生成密钥对</li>
</ul>
<p>点击Xshell菜单栏上的”工具”-&gt;”新建用户密钥生成向导”，按下图操作生成和保存密钥对。</br><br>密钥类型默认RSA，长度2048位，名称随意，密码可选，最后把用户密钥也导出来(非必要步骤，保存以备复用)。<br><img src="https://pic.downk.cc/item/5f96728d1cd1bbb86bcbb354.gif" alt="image"></p>
<p><strong>两种方法都可以显式地看到生成文件</strong>：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>id_rsa_mars.pub</td>
<td>公钥(主机密钥)，保存到服务器上，来验证请求登录用户的私钥</td>
</tr>
<tr>
<td>id_rsa_mars</td>
<td>私钥(用户密钥)，SSH登录时指定，提供给服务器进行登录验证</td>
</tr>
</tbody></table>
<h3 id="服务器注册公钥"><a href="#服务器注册公钥" class="headerlink" title="服务器注册公钥"></a>服务器注册公钥</h3><p>需要把公钥添加到要登录的用户家目录下的.ssh路径下的authorized_keys文件中，一个便捷的方式是使用 ssh-copy-id 命令上传公钥，这一步需要登录用户的密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i 公钥路径 登录用户名@登录主机名或ip -p 端口</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh-copy-id -i id_rsa_mars.pub pi@192.168.0.125 -p 22</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;id_rsa_mars.pub&quot;</span><br><span class="line">The authenticity of host &#39;[192.168.0.125]:22 ([192.168.0.125]:22)&#39; can&#39;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:YG43kzBF5jzsbL2yo9Uw&#x2F;negmUvVMyiGACksK5&#x2F;ppUc.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">pi@192.168.0.125&#39;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh -p &#39;22&#39; &#39;pi@192.168.0.125&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line"></span><br><span class="line"># 检查是否上传完成</span><br><span class="line">pi@raspberrypi:~ $ cat .ssh&#x2F;authorized_keys </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1BzYNq7RB5&#x2F;OCXVbPIs6EGj2OjS9ug0mHpdFgWngLFAaC3&#x2F;msX9kvgLvM90mklExljtCXu3mNXiPDJpItWiQJcdKn90leciEtgJQiAa&#x2F;hNbIeurGrN6D9+uCYbNFjzwezTTEghXzeHCC&#x2F;aP+M3M+TbyLSTAdadcSSFQJ8jgYh&#x2F;wYvgeR03tSZrfwoFvkKeiep0z4P1hKz7weMPGpr+GIW3egutx&#x2F;8gXfJ80ZE8ErPUsdasmsyHSNO3SjkDpXXarMkeb8bc6LLrZaxtp4uPw9M7YLcyuiLvUjyHvqM7D4Kh4bDJTXOL5mpVdAXrB3C8a32hMzwzn6REW1o6Yqh8Tl6qw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h3 id="客户端登录时指定私钥"><a href="#客户端登录时指定私钥" class="headerlink" title="客户端登录时指定私钥"></a>客户端登录时指定私钥</h3><ul>
<li>方法一：使用ssh命令指定私钥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i 私钥路径 登录用户名@登录主机名或ip -p 端口</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh -i id_rsa_mars pi@192.168.0.125 -p 21414</span><br><span class="line">Linux raspberrypi 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU&#x2F;Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU&#x2F;Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Mon Oct 26 16:17:34 2020 from 192.168.137.1</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Xshell指定用户密钥</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f9688021cd1bbb86bd16d11.jpg" alt="image"></p>
<h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>1.权限问题，改为0600即可解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh -i id_rsa_mars -p 21414 &#39;pi@103.46.128.21&#39;</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0777 for &#39;id_rsa_mars&#39; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;id_rsa_mars&quot;: bad permissions</span><br><span class="line">pi@103.46.128.21&#39;s password:</span><br><span class="line"></span><br><span class="line">mars@company:~&#x2F;.ssh$ chmod 0600 id_rsa_mars   #修改私钥权限为0600</span><br></pre></td></tr></table></figure>

<p>2.ssh -i指定密钥登录仍需要输入密码，Xshell提示<strong>所选的用户密钥未在远程主机上注册</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原因是公钥(主机密钥)没有添加成功，重新添加后即可解决</span><br></pre></td></tr></table></figure>

<h3 id="ssh命令备忘"><a href="#ssh命令备忘" class="headerlink" title="ssh命令备忘"></a>ssh命令备忘</h3><ul>
<li><p>从某主机的80端口开启到本地主机2001端口的隧道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -N -L2001:localhost:80 somemachine</span><br></pre></td></tr></table></figure>
<p>现在你可以直接在浏览器中输入<a href="http://localhost:2001访问这个网站。">http://localhost:2001访问这个网站。</a></p>
</li>
<li><p>直接连接到只能通过主机B连接的主机A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -t hostA ssh hostB</span><br></pre></td></tr></table></figure>
<p>当然，你要能访问主机A才行。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>QtVS开发环境配置篇</title>
    <url>/QtVS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="1-Visual-studio-2019-的安装"><a href="#1-Visual-studio-2019-的安装" class="headerlink" title="1. Visual studio 2019 的安装"></a>1. Visual studio 2019 的安装</h1><p>a) 点此<a href="https://visualstudio.microsoft.com/zh-hans/vs/">地址</a>进入 Visual Studio 官网，下载 Community 2019 版(实际下载的为安装器)<br><img src="https://pic.downk.cc/item/5f752469160a154a67f65681.jpg" alt="vs2019社区版"></p>
<a id="more"></a>
<p>b) 安装完后会启动 Visual Studio Installer 安装器，工作负载勾选“使用C++的桌面开发”后直接进行安装即可<br><img src="https://pic.downk.cc/item/5f752c0c160a154a67f7be78.jpg" alt="vs2019安装组件"></p>
<h1 id="2-Qt-5-14-2-的安装"><a href="#2-Qt-5-14-2-的安装" class="headerlink" title="2. Qt 5.14.2 的安装"></a>2. Qt 5.14.2 的安装</h1><p>a) 从此<a href="http://download.qt.io/official_releases/qt/5.14/5.14.2/">镜像站</a>下载会自动选择最近的镜像地址，下载如下版本<br><img src="https://pic.downk.cc/item/5f76d259160a154a6754183f.jpg" alt="image"><br>b) 下载完成后安装，注册登录后一直下一步到此界面，红框内为必勾选项目，完成安装<br><img src="https://pic.downk.cc/item/5f76d497160a154a6754b6f1.jpg" alt="image"></p>
<h1 id="3-Qt-Visual-Studio-Tools-扩展的安装"><a href="#3-Qt-Visual-Studio-Tools-扩展的安装" class="headerlink" title="3. Qt Visual Studio Tools 扩展的安装"></a>3. Qt Visual Studio Tools 扩展的安装</h1><p>a) 安装Qt Visual Studio Tools的方法有两种，一种是源码编译，参考<a href="https://wiki.qt.io/Visual_Studio_Add-in">这里</a>。<br><br>b) 另一种是通过VS自带的插件管理器安装，步骤如下：<br><br>启动VS2019,选择继续但无需代码进入到主界面<br><img src="https://pic.downk.cc/item/5f76d70d160a154a675553fe.jpg" alt="image"><br>c) 从菜单栏依次点击“扩展-&gt;管理扩展”，打开界面后，先点联机，在输入框搜索Qt，点下载Qt Visual Studio Tools，因为众所周知的原因，下载插件的速度较慢，此外还可以通过右边的详细信息拿到下载地址的url，用度盘离线下载，我分享一个已经下载好的，<a href="https://pan.baidu.com/s/1MkwPsNwEyANAAbQeoSJfMw">提取码：7692</a><br><img src="https://pic.downk.cc/item/5f76d933160a154a6755e924.jpg" alt="image"><br>关闭VS2019后,安装下载的插件(通过管理扩展页面下载的插件可以跳过下面的安装过程)，<img src="https://pic.downk.cc/item/5f76db8f160a154a67568e6e.jpg" alt="image"><br>安装完成后再次启动VS2019</p>
<h1 id="4-Qt-Visual-Studio-Tools-插件的配置"><a href="#4-Qt-Visual-Studio-Tools-插件的配置" class="headerlink" title="4. Qt Visual Studio Tools 插件的配置"></a>4. Qt Visual Studio Tools 插件的配置</h1><p>a)  从菜单栏依次点击“扩展-&gt;Qt VS Tools-&gt;Qt Options”，按下图点开扩展中的 Qt Options<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f90.jpg"><br>b) 弹出Qt Options页面后，点击Add按钮弹出以下界面，再点击Path行最右侧的按钮。<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f93.jpg"><br>c) 定位到Qt 5.14.2的安装路径，默认为C:\Qt\Qt5.14.2\5.14.2\msvc2017和C:\Qt\Qt5.14.2\5.14.2\msvc2017_64，添加这两个编译平台，Default配置随意，保存即可完成配置<br><img src="https://pic.downk.cc/item/5f7f26761cd1bbb86bd01d62.jpg"></p>
]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title>人类一思考上帝就发笑</title>
    <url>/%E4%BA%BA%E7%B1%BB%E4%B8%80%E6%80%9D%E8%80%83%E4%B8%8A%E5%B8%9D%E5%B0%B1%E5%8F%91%E7%AC%91.html</url>
    <content><![CDATA[<h3 id="为什么说移位运算在运行时比普通乘除法效率高"><a href="#为什么说移位运算在运行时比普通乘除法效率高" class="headerlink" title="为什么说移位运算在运行时比普通乘除法效率高"></a>为什么说移位运算在运行时比普通乘除法效率高</h3><hr>
<p>见如下反汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="number">004117</span>DE  mov         dword ptr [a],<span class="number">0</span> </span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">-16</span>;</span><br><span class="line"><span class="number">004117E5</span>  mov         dword ptr [b],<span class="number">0F</span>FFFFFF0h </span><br><span class="line">	a = b / <span class="number">8</span>;</span><br><span class="line"><span class="number">004117</span>EC  mov         eax,dword ptr [b] </span><br><span class="line"><span class="number">004117</span>EF  cdq         <span class="comment">//使用eax的第31位(即符号位填充edx)</span></span><br><span class="line"><span class="number">004117F</span>0  <span class="keyword">and</span>         edx,<span class="number">7</span> </span><br><span class="line"><span class="number">004117F</span>3  add         eax,edx </span><br><span class="line"><span class="number">004117F</span>5  sar         eax,<span class="number">3</span> </span><br><span class="line"><span class="number">004117F</span>8  mov         dword ptr [a],eax </span><br><span class="line">	a = b &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="number">004117F</span>B  mov         eax,dword ptr [b] </span><br><span class="line"><span class="number">004117F</span>E  sar         eax,<span class="number">3</span> </span><br><span class="line"><span class="number">00411801</span>  mov         dword ptr [a],eax </span><br></pre></td></tr></table></figure>
<p>可以看到，一条除法语句被编译成6条机器指令，而以为指令只有三条。<br>从效率上看，使用移位指令有更高的效率，因为移位指令占用更少的机器周期。<br>从硬件上看，移位对硬件更容易实现，移一位就乘/除2，所以会用移位。</p>
<h3 id="函数调用过程中，函数参数的入栈顺序，为什么？"><a href="#函数调用过程中，函数参数的入栈顺序，为什么？" class="headerlink" title="函数调用过程中，函数参数的入栈顺序，为什么？"></a>函数调用过程中，函数参数的入栈顺序，为什么？</h3><hr>
<p>C语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式。<br>C方式参数入栈顺序（从右至左）的好处就是可以动态变化参数个数。<br>通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。<br>除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。<br>这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。<br>从右至左则最左边的参数在栈顶</p>
<h3 id="结构体大小的影响因素"><a href="#结构体大小的影响因素" class="headerlink" title="结构体大小的影响因素"></a>结构体大小的影响因素</h3><hr>
<ul>
<li>编译器，编译参数和操作系统位数 –影响基础类型的大小和指针大小</li>
<li>#pragma pack(1) –伪指令指定的对齐模数</li>
<li>对齐模数，该模数是【#pragma pack指定的数值】、【未指定#pragma pack时，系统默认的对齐模数（32位系统为4字节，64位为8字节）】和【结构体内部最大的基本数据类型成员】长度中数值较小者，结构体成员不能跨对齐模数的倍数</li>
</ul>
<p>各个类型的变量长度由编译器来决定（实际上与操作系统位数和编译器都有关）<br>可用sizeof得到，当前主流编译器一般是32位或64位</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">32位</th>
<th align="left">64位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="center">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="center">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">int</td>
<td align="center">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="center">4</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">long long int</td>
<td align="center">8</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">char*</td>
<td align="center">4</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">float</td>
<td align="center">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">double</td>
<td align="center">8</td>
<td align="left">8</td>
</tr>
</tbody></table>
<h3 id="结构体对齐包括两个方面的含义"><a href="#结构体对齐包括两个方面的含义" class="headerlink" title="结构体对齐包括两个方面的含义"></a>结构体对齐包括两个方面的含义</h3><hr>
<ul>
<li>结构体总长度；</li>
<li>结构体内各数据成员的内存对齐，即该数据成员相对结构体的起始位置；</li>
</ul>
<h3 id="内存对齐的意义"><a href="#内存对齐的意义" class="headerlink" title="内存对齐的意义"></a>内存对齐的意义</h3><hr>
<p>许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的起始地址的值是某个数k的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。这种强制的要求一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度。<br>结构体对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始一次读取4字节的内存数据，假如软件能保证int类型的数据都从4倍数地址开始，那么读或写一个int类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的4字节内存块上，因此需要在内存中存放数据时进行对齐。</p>
<h3 id="一个伪造的IP能否跟服务端建立TCP连接通信"><a href="#一个伪造的IP能否跟服务端建立TCP连接通信" class="headerlink" title="一个伪造的IP能否跟服务端建立TCP连接通信?"></a>一个伪造的IP能否跟服务端建立TCP连接通信?</h3><hr>
<p>不可能的，因为TCP是面向连接的协议，每个连接都需要经过三次握手建立连接。<br>client发送syn报文给服务端，服务端响应syn+ack报文，由于IP是伪造的，伪造的IP是接收不到服务端响应的syn+ack报文并返回ack的，也就是说三次握手根本不能正常完成，TCP连接是不可能建立的。本文讲的伪造IP欺骗服务端是基于服务端获取IP的原理，修改http请求头，完成的欺骗。其底层建立TCP通信链路的IP，肯定是真实存在的，要不然没办法进行通信和交互。<br>如果攻击者使用大量伪造IP，发送syn报文给服务器，会导致服务器半连接队列堆满，正常用户无法和服务器建立TCP连接，也就是所谓的syn flood攻击(DDOS攻击中的一种)。</p>
<h3 id="一个伪造的IP能否跟服务器以UDP协议进行通信"><a href="#一个伪造的IP能否跟服务器以UDP协议进行通信" class="headerlink" title="一个伪造的IP能否跟服务器以UDP协议进行通信"></a>一个伪造的IP能否跟服务器以UDP协议进行通信</h3><hr>
<p>单向通信，client只能单向的发送数据给服务端，同样由于IP是伪造的，接收不到服务返回的UDP报文。UDP是一个面向非连接的协议，建立通信前不需要经过三次握手建立连接，也没有消息确认ack,超时重传等保障数据安全传输的机制。但是如果大量伪造的IP，发送垃圾数据给服务器，会造成服务瘫痪，影响正常用户使用，也就是所谓的udp flood攻击(DDOS攻击中的一种)。</p>
<h3 id="简单介绍OSI参考模型"><a href="#简单介绍OSI参考模型" class="headerlink" title="简单介绍OSI参考模型"></a>简单介绍OSI参考模型</h3><hr>
<p><img src="https://pic.imgdb.cn/item/60af47dd08f74bc159fee68d.png" alt="OSI七层模型"></p>
<ol>
<li>应用层<br>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</li>
<li>表示层<br>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</li>
<li>会话层<br>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</li>
<li>传输层<br>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</li>
<li>网络层<br>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</li>
<li>数据链路层<br>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</li>
<li>物理层<br>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。</li>
</ol>
<ul>
<li>通信特点：对等通信<br>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</li>
</ul>
<h3 id="TCP-IP五层协议和OSI的七层协议对应关系"><a href="#TCP-IP五层协议和OSI的七层协议对应关系" class="headerlink" title="TCP/IP五层协议和OSI的七层协议对应关系"></a>TCP/IP五层协议和OSI的七层协议对应关系</h3><hr>
<p><img src="https://pic.imgdb.cn/item/60af4ee208f74bc159582f82.png"><br><img src="https://pic.imgdb.cn/item/60af4efe08f74bc1595998be.png"></p>
<h3 id="进程间-线程间共享的资源，通信的方式有哪些？"><a href="#进程间-线程间共享的资源，通信的方式有哪些？" class="headerlink" title="进程间/线程间共享的资源，通信的方式有哪些？"></a>进程间/线程间共享的资源，通信的方式有哪些？</h3><hr>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer_03.从尾到头打印链表</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2003.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList<br>链表结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>


<h3 id="方法一：先入栈，再出栈"><a href="#方法一：先入栈，再出栈" class="headerlink" title="方法一：先入栈，再出栈"></a>方法一：先入栈，再出栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt;</span><br><span class="line">        <span class="comment">//遍历链表，将链表节点压栈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != head) &#123;</span><br><span class="line">            st.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈并压入向量容器</span></span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            vt.push_back(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用std-reverse-函数"><a href="#方法二：使用std-reverse-函数" class="headerlink" title="方法二：使用std::reverse()函数"></a>方法二：使用std::reverse()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != head) &#123;</span><br><span class="line">            vt.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(vt.begin(), vt.end());</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：使用递归"><a href="#方法三：使用递归" class="headerlink" title="方法三：使用递归"></a>方法三：使用递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != head) &#123;</span><br><span class="line">            vt = printListFromTailToHead(head-&gt;next);</span><br><span class="line">            vt.push_back(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法四：反转链表"><a href="#方法四：反转链表" class="headerlink" title="方法四：反转链表"></a>方法四：反转链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* tmp = head;</span><br><span class="line">        <span class="comment">//cur为空是说明链表到头了，第一个元素为pre</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt;</span><br><span class="line">        <span class="keyword">while</span> (pre) &#123;</span><br><span class="line">            vt.push_back(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10.二进制中1的个数</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2010.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。<br>例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h3 id="可能引起死循环的解法"><a href="#可能引起死循环的解法" class="headerlink" title="可能引起死循环的解法"></a>可能引起死循环的解法</h3><p>判断当前数字不等于0时，与1做与运算，如果为1，增加计数；右移；重复这个过程直到数字等于0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n%<span class="number">2</span>)</span><br><span class="line">                count++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果输入为负数，符号位1右移一位，同时符号位仍会设为1，最终会变成0xFFFFFFFF而陷入死循环。</p>
<h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><p>依次与2的0次方，2的1次方直到2的31次方做与运算，在与运算的结果为大于0的时候增加计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; flag)</span><br><span class="line">                count++;</span><br><span class="line">            flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="让人眼前一亮的解法"><a href="#让人眼前一亮的解法" class="headerlink" title="让人眼前一亮的解法"></a>让人眼前一亮的解法</h3><p>上面的解法总是要完成32循环。考虑一个二进制数表示为1100，如果这个数减去1，变成1011，即这个数减1后，对比<b>1100, 1011</b>原先的末位1变成0，末尾1后面的0全部变成了1，我们再将两数相与，就可以完成<b>消除原来数字的末尾1</b>操作，关于计数部分，再减一之前判断是否不等于0即可，这个循环的次数由二进制中1的数量决定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= n<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="延伸-一条语句判断一个整数是不是2的整数次方"><a href="#延伸-一条语句判断一个整数是不是2的整数次方" class="headerlink" title="延伸: 一条语句判断一个整数是不是2的整数次方"></a>延伸: 一条语句判断一个整数是不是2的整数次方</h3><p>这个数满足二进制有且只有1位为1的条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n&amp;n<span class="number">-1</span>==<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="延伸-给定两个数m，n，问改变n二进制中的多少个位值，能使n等于m"><a href="#延伸-给定两个数m，n，问改变n二进制中的多少个位值，能使n等于m" class="headerlink" title="延伸: 给定两个数m，n，问改变n二进制中的多少个位值，能使n等于m"></a>延伸: 给定两个数m，n，问改变n二进制中的多少个位值，能使n等于m</h3><p>先求异或结果s，再求s里二进制为1的个数</p>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><blockquote>
<p>把一个整数减去 1 之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的末位1变成0。很多二进制问题都可以应用这种思路。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 数值的整数次方</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
<h3 id="不过脑子的写法"><a href="#不过脑子的写法" class="headerlink" title="不过脑子的写法"></a>不过脑子的写法</h3><p>判断当前数字不等于0时，与1做与运算，如果为1，增加计数；右移；重复这个过程直到数字等于0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;abs_n; i++) &#123;</span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>未考虑指数为非正数的情况。</p>
<h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><p>指数为负数时，先求指数的绝对值做幂运算，再用1.0除以结果，注意此时底数为0的情况，除以 0 会导致抛出浮点数异常，这里我们直接返回0。<b>需要注意的是浮点数的比较。</b></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x&gt;<span class="number">-0.0000001</span> &amp;&amp; x&lt;<span class="number">0.0000001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_n = <span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;abs_n; i++) &#123;</span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="更高效的解法"><a href="#更高效的解法" class="headerlink" title="更高效的解法"></a>更高效的解法</h3><p>上面的for循环次数用指数来指定，即与n线性相关。有下面的公式可以化线性O(N)为O(logN)<br><img src="https://pic.imgdb.cn/item/60b0b91f08f74bc15978d7d1.png"><br>考虑用循环或二者递归来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;<span class="number">-0.0000001</span> &amp;&amp; x&lt;<span class="number">0.0000001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_n = <span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (abs_n) &#123;</span><br><span class="line">            <span class="comment">//a^n = (a^2)^(n&gt;&gt;1) [* a //为奇数时];</span></span><br><span class="line">            <span class="keyword">if</span> (abs_n &amp; <span class="number">1</span>)</span><br><span class="line">                ans = ans * x;</span><br><span class="line">            abs_n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="number">1.0</span> / ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myExponent</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> result = myExponent(x, n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;<span class="number">-0.0000001</span> &amp;&amp; x&lt;<span class="number">0.0000001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_n = <span class="built_in">abs</span>(n);</span><br><span class="line">        result = myExponent(x, abs_n);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><b>有一个额外情况是，当n为最小的负数 -2147483648 时, 存储abs运算结果的abs_n变量如果定义为int，则仍然为负数，对负数进行移位操作并判断会导致死循环</b></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 12. 打印从1到最大的n位数</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2012.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.html</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h3 id="不过脑子的写法"><a href="#不过脑子的写法" class="headerlink" title="不过脑子的写法"></a>不过脑子的写法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_minus_one = <span class="built_in">pow</span>(<span class="number">10</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;max_minus_one; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>未考虑大数的情况；<br>未考虑n为非正数的情况。</p>
<h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><p>使用字符串模拟大数，注意处理进位和上限的判断。如果使用strcmp(number, “99…999”)判断，则其算法复杂度为O(n)。<br>可以检测首位是否产生了进位。<br>值得注意的是字符串打印时应跳过最开始的连续<b>‘0’</b>字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span> * number, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isOverFlow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> isTakeOver = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> nSum = number[i] - <span class="string">&#x27;0&#x27;</span> + isTakeOver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==n<span class="number">-1</span>) nSum++;</span><br><span class="line">            <span class="keyword">if</span> (nSum&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line">                    isOverFlow = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nSum -= <span class="number">10</span>;</span><br><span class="line">                    number[i] = <span class="string">&#x27;0&#x27;</span> + nSum;</span><br><span class="line">                    isTakeOver = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                number[i] = <span class="string">&#x27;0&#x27;</span> + nSum;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isOverFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span> * number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (number[++i]==<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; number+i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">        number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Increment(number, n)) &#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="考虑用全排列递归来实现"><a href="#考虑用全排列递归来实现" class="headerlink" title="考虑用全排列递归来实现"></a>考虑用全排列递归来实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span> * number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (number[++i]==<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; number+i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToNRecursively</span><span class="params">(<span class="keyword">char</span> *number, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==length) &#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            number[index] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            print1ToNRecursively(number, index+<span class="number">1</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">        number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        print1ToNRecursively(number, <span class="number">0</span>, <span class="built_in">strlen</span>(number));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体对齐</title>
    <url>/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90.html</url>
    <content><![CDATA[<h3 id="结构体大小的影响因素"><a href="#结构体大小的影响因素" class="headerlink" title="结构体大小的影响因素"></a>结构体大小的影响因素</h3><ul>
<li>编译器，编译参数和操作系统位数 –影响基础类型的大小和指针大小</li>
<li>#pragma pack(1) –伪指令指定的对齐模数</li>
<li>对齐模数，该模数是【#pragma pack指定的数值】、【未指定#pragma pack时，系统默认的对齐模数（32位系统为4字节，64位为8字节）】和【结构体内部最大的基本数据类型成员】长度中数值较小者，结构体成员不能跨对齐模数的倍数</li>
</ul>
<p>各个类型的变量长度由编译器来决定（实际上与操作系统位数和编译器都有关）<br>可用sizeof得到，当前主流编译器一般是32位或64位<br>|类型|32位|64位|<br>| —— | —— | —— |<br>|char|1|1|<br>|short int|2|2|<br>|int|4|4|<br>|long int |4|8|<br>|long long int|8|8|<br>|char*| 4|8|<br>|float| 4|4|<br>|double |8|8|</p>
<h3 id="结构体对齐包括两个方面的含义"><a href="#结构体对齐包括两个方面的含义" class="headerlink" title="结构体对齐包括两个方面的含义"></a>结构体对齐包括两个方面的含义</h3><ul>
<li>结构体总长度；</li>
<li>结构体内各数据成员的内存对齐，即该数据成员相对结构体的起始位置；</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s4</span>&#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空结构体在使用C编译器为<b>0字节</b>，使用C++编译器为<b>1字节</b></p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> j[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> e;</span><br><span class="line">    <span class="keyword">char</span> g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内嵌结构体s3只是一个声明，不占空间，64位编译环境下char*位8字节<br>总体大小为a+j[1+3+4] + c[16] + e[8] + g[1+7] = 40</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">s3</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;s3;</span><br><span class="line">    <span class="keyword">char</span> j[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> e;</span><br><span class="line">    <span class="keyword">char</span> g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内嵌结构体s3占用空间，先计算s3的大小为d[8] + b+i[3+4+1] = 16,对齐系数最大为8<br>s4内最大的基础类型的大小为8，因此对齐系数也为8<br>总体大小为a[1+7]+s3[16]+j[3+5]+c[16]+e[8]+g[1+7] = 64</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">s3</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;s3;</span><br><span class="line">    <span class="keyword">char</span> j[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> e;</span><br><span class="line">    <span class="keyword">char</span> g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>传说中没有对齐的世界，大小为44</p>
<h3 id="内存对齐的意义"><a href="#内存对齐的意义" class="headerlink" title="内存对齐的意义"></a>内存对齐的意义</h3><hr>
<p>许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的起始地址的值是某个数k的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。这种强制的要求一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度。<br>结构体对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始一次读取4字节的内存数据，假如软件能保证int类型的数据都从4倍数地址开始，那么读或写一个int类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的4字节内存块上，因此需要在内存中存放数据时进行对齐。</p>
]]></content>
      <tags>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>目标文件的秘密</title>
    <url>/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%A7%98%E5%AF%86.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>剑指 Offer 13. 删除链表的节点</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2013.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9.html</url>
    <content><![CDATA[<h3 id="题目描述No-1"><a href="#题目描述No-1" class="headerlink" title="题目描述No.1"></a>题目描述No.1</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p>
<h3 id="双指针没什么好说的"><a href="#双指针没什么好说的" class="headerlink" title="双指针没什么好说的"></a>双指针没什么好说的</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* n_pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* n_cur = head;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n_cur &amp;&amp; n_cur-&gt;val!=val) &#123;</span><br><span class="line">            n_pre = n_cur;</span><br><span class="line">            n_cur = n_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n_cur==head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n_cur)&#123;</span><br><span class="line">            n_pre-&gt;next = n_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题目描述No-2"><a href="#题目描述No-2" class="headerlink" title="题目描述No.2"></a>题目描述No.2</h3><p>给定单向链表的头指针和一个要删除的节点，定义一个函数在<b>O(1)的时间复杂度内</b>删除该节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode** head, ListNode* needDelete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !needDelete) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needDelete-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除节点不是尾节点，算法复杂度为O(1)</span></span><br><span class="line">            ListNode* pNext = needDelete-&gt;next;</span><br><span class="line">            needDelete-&gt;val = pNext-&gt;val;</span><br><span class="line">            needDelete-&gt;next = pNext-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pNext;</span><br><span class="line">            pNext = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*head==needDelete) &#123;</span><br><span class="line">            <span class="comment">//删除节点是头节点，同时不满足上面的if，也是尾节点，算法复杂度为O(1)</span></span><br><span class="line">            <span class="keyword">delete</span> needDelete;</span><br><span class="line">            needDelete = <span class="literal">NULL</span>;</span><br><span class="line">            *head = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点尾节点，算法复杂度为O(n)</span></span><br><span class="line">            ListNode* pNode = *head;</span><br><span class="line">            <span class="keyword">while</span> (pNode-&gt;next!=needDelete) &#123;</span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> needDelete;</span><br><span class="line">            needDelete = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总的平均时间复杂度为[(n-1)*O(1)+O(n)]/n = O(1)</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14. 调整数组顺序使奇数位于偶数前面</title>
    <url>/%E5%89%91%E6%8C%87%20Offer%2014.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size()==<span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">auto</span> left = nums.begin(), right = nums.end()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; (*left &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; (*right &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">auto</span> num = *left;</span><br><span class="line">                *left = *right;</span><br><span class="line">                *right = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h3><p>对奇偶数判断部分进行解耦合，以应对比如</p>
<ul>
<li>能被三整除的部分放前面，不能整除的部分后面</li>
<li>负数放前面，非负数放后面<br>等情况<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &amp; <span class="number">0x1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_split_by3</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size()==<span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">auto</span> left = nums.begin(), right = nums.end()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; func(*left)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; !func(*right)) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">auto</span> num = *left;</span><br><span class="line">                *left = *right;</span><br><span class="line">                *right = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
