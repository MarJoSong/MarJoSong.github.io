<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++内存布局</title>
    <url>/C-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<h3 id="1-内存分布图"><a href="#1-内存分布图" class="headerlink" title="1. 内存分布图"></a>1. 内存分布图</h3><p><img src="https://pic.imgdb.cn/item/5f729e85160a154a675a2493.png" alt="Memory Sort Map"></p>
<a id="more"></a>
<p><font color=green size=4>1. Stack段：局部变量存放区域。</font><br><font color=green size=4>2. heap段：用户动态分配内存区域。</font><br><font color=green size=4>3. bss段：存放未初始化的全局或静态变量内存区域。(Block Started by Symbol)</font><br><font color=green size=4>4. 数据段：通常指存放已初始化的全局变量的内存区域。(data segment)</font><br><font color=green size=4>5. 代码段：通常指存放程序执行代码的一块内存区域。(code segment/text segment)</font></p>
<blockquote>
<p>C规定，未初始化变量的初值为0，这个清0的操作是由<strong>启动代码</strong>完成的，还有已初始化变量的初值的设置，也是由<strong>启动代码</strong>完成的。<br>为了启动代码的简单化，编译链接器会把已初始化的变量放在同一个段：.data，这个段的映像（包含了各个变量的初值）保存在“只读数据段”，这样启动代码就可以简单地复制这个映像到 .data 段，所有的已初始化变量就都初始化了。<br>而未初始化变量也放在同一个段：.bss，启动代码简单地调用 memset 就可以把所有未初始化变量都清0。</p>
</blockquote>
<hr>
<h3 id="2-在C中分为5个存储区"><a href="#2-在C中分为5个存储区" class="headerlink" title="2. 在C中分为5个存储区"></a>2. 在C中分为5个存储区</h3><p><font color=green size=4>1. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似数据结构中的栈。</font><br><font color=green size=4>2. 堆区:一般由程序员分配和释放(malloc,alloc,realloc,free)，程序结束时内存空间由系统回收，与数据结构的堆毫无关系。</font><br><font color=green size=4>3. 全局/静态区：全局变量和静态变量的存储是在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</font><br><font color=green size=4>4. 文字常量区：常量和字符串就是存放在这里，程序结束后由系统释放。</font><br><font color=green size=4>5. 程序代码区：存放函数体的二进制代码。</font></p>
<blockquote>
<p>所有函数体外定义的变量就是全局变量，加了static修饰符后不管在哪里都存放在全局（静态区），全局的static变量只对该文件中有效，不能extern到别的文件用，在函数体内部定义的static表示在该函数体内有效。另外，函数体中的这样的字符串字面量存放在常量区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span>* p ;<span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//s在栈，abc在字符常量区</span></span><br><span class="line">	<span class="keyword">char</span> *p2 ;<span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p3 = <span class="string">&quot;abcdef&quot;</span><span class="comment">//p3栈，abcdef在字符常量区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">	p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//在堆上开辟10个字节的内存，p1本身在栈中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-C-C-中堆区和自由存储区的区别与联系"><a href="#3-C-C-中堆区和自由存储区的区别与联系" class="headerlink" title="3. C/C++中堆区和自由存储区的区别与联系"></a>3. C/C++中堆区和自由存储区的区别与联系</h3><p><font color=green size=4>1. malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放。</font><br><font color=green size=4>2. 堆(heap)是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存释放。自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，即缺省的全局运算符new和delete会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</font></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C测试框架</title>
    <url>/C%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<p>cmake:     3.13.4<br>g++:       8.3.0 (Raspbian 8.3.0-6+rpi1)<br>CXX_STD:c++11</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:code $ mkdir testFrame &amp;&amp; git <span class="built_in">clone</span> https://github.com/google/googletest.git</span><br><span class="line">pi@raspberrypi:code $ <span class="built_in">cd</span> googletest &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">pi@raspberrypi:build $ cmake ../	<span class="comment">#省略cmake输出</span></span><br><span class="line">pi@raspberrypi:build $ make		<span class="comment">#略make输出，如有报错，尝试在CMakelist.txt增加SET(CMAKE_CXX_FLAGS &quot;-std=c++0x&quot;)</span></span><br><span class="line">pi@raspberrypi:build $ cp lib ../../testFrame/ -r</span><br><span class="line">pi@raspberrypi:build $ cp ../googletest/include/ ../../testFrame/ -r</span><br><span class="line">pi@raspberrypi:build $ <span class="built_in">cd</span> ../../testFrame/</span><br><span class="line">pi@raspberrypi:testFrame $ vim main.cpp	<span class="comment">#main.cpp源码单独放在一个代码块里</span></span><br><span class="line">pi@raspberrypi:testFrame $ g++ -I./include -L./lib -o main main.cpp -lgtest -lpthread</span><br><span class="line">pi@raspberrypi:testFrame $ ./main </span><br><span class="line">hello world</span><br><span class="line">add(3, 4) = 7</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from <span class="built_in">test</span></span><br><span class="line">[ RUN      ] test.add1</span><br><span class="line">[       OK ] test.add1 (0 ms)</span><br><span class="line">[ RUN      ] test.add2</span><br><span class="line">main.cpp:21: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  add(3, 4)</span><br><span class="line">    Which is: 7</span><br><span class="line">  6</span><br><span class="line">[  FAILED  ] test.add2 (0 ms)</span><br><span class="line">[----------] 2 tests from <span class="built_in">test</span> (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] test.add2</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTICE - DO NOT IGNORE:</span><br><span class="line">This <span class="built_in">test</span> program did NOT call testing::InitGoogleTest() before calling RUN_ALL_TESTS(). This is INVALID. Soon Google Test will start to enforce the valid usage. Please fix it ASAP, or IT WILL START TO FAIL.</span><br></pre></td></tr></table></figure>
<p>tttttt</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(test, add1) &#123;</span><br><span class="line">	EXPECT_EQ(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_NE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_LT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>);</span><br><span class="line">	EXPECT_LE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_GT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_GE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(test, add2) &#123;</span><br><span class="line">	EXPECT_EQ(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_NE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_LT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>);</span><br><span class="line">	EXPECT_LE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">	EXPECT_GT(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>);</span><br><span class="line">	EXPECT_GE(add(<span class="number">3</span>, <span class="number">4</span>), <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;add(3, 4) = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>


]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>gtest</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译过程</title>
    <url>/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h3 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h3><hr>
<p><img src="https://pic.imgdb.cn/item/5f73f793160a154a67b421a5.jpg" alt="C程序编译过程"></p>
<a id="more"></a>
<p>GCC编译一个C/C++ 程序到可执行程序可分成以上4个步骤。例如，”gcc-o hello.exe hello.c”执行如下:</p>
<h6 id="1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。"><a href="#1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。" class="headerlink" title="1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。"></a>1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp hello.c &gt; hello.i</span></span><br></pre></td></tr></table></figure>
<p>生成的文件”hello.i”包含了展开扩展后的源码。</p>
<h6 id="2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。"><a href="#2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。" class="headerlink" title="2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。"></a>2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i</span></span><br></pre></td></tr></table></figure>
<p>选项 -S 指定生成汇编代码，而不是目标代码。生成的汇编文件为”hello.s”。</p>
<h6 id="3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。"><a href="#3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。" class="headerlink" title="3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。"></a>3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s</span></span><br></pre></td></tr></table></figure>

<h6 id="4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。"><a href="#4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。" class="headerlink" title="4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。"></a>4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello.exe hello.o ...libraries...</span></span><br></pre></td></tr></table></figure>

<p>Verbose Mode (-v)<br>可以通过启用-v (verbose)选项查看详细的编译过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br></pre></td></tr></table></figure>

<p>Defining Macro (-D)<br>可以使用-Dname选项定义宏，或者使用-Dname=value定义带有值的宏。如果值包含空格，则应该用双引号括起来。</p>
<h3 id="头文件-h-，静态库-a-lib-和动态库-so-dll"><a href="#头文件-h-，静态库-a-lib-和动态库-so-dll" class="headerlink" title="头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)"></a>头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)</h3><hr>
<h5 id="静态库-VS-动态库"><a href="#静态库-VS-动态库" class="headerlink" title="静态库 VS 动态库"></a>静态库 VS 动态库</h5><p>库是可以通过链接器链接到程序中的预编译过的目标文件的集合，例如系统函数printf()和sqrt()。<br><br>外部库有两种类型:静态库和共享库。<br></p>
<ol>
<li>静态库的文件扩展名在Unix中为”.a”(归档文件)在Windows中为”.lib”。当链接静态库到程序时，程序中使用的外部函数的机器码将复制到可执行文件中。静态库可以通过”ar”存档程序创建。<br></li>
<li>共享库的文件扩展名在Unix中为”.lib”(共享对象)在Windows中为”dll”(动态链接库)。当链接共享库到程序时，只会在可执行文件中创建一个小表。在可执行文件开始运行之前，操作系统加载外部函数所需的机器码——这个过程称为动态链接。动态链接使可执行文件更小并节省磁盘空间，因为库的一个副本可以在多个程序之间共享。此外，大多数操作系统允许内存中共享库的一个副本被所有正在运行的程序使用，从而节省内存。可以升级共享库代码，而不需要重新编译程序。</li>
</ol>
<p>由于动态链接的优点，默认情况下，如果共享库可用，GCC会链接到共享库。<br><br>您可以通过 <font color=red>nm file</font> 列出库的内容。</p>
<h5 id="搜索头文件和库-I-L-and-l"><a href="#搜索头文件和库-I-L-and-l" class="headerlink" title="搜索头文件和库(-I, -L and -l)"></a>搜索头文件和库(-I, -L and -l)</h5><p>在编译程序时，编译器需要头文件来编译源代码;链接器需要这些库来解析来自其他对象文件或库的外部引用。除非您设置了适当的选项，否则编译器和链接器将无法找到头文件/库。<br><br>对于源代码中使用的每个头文件(通过#include指令)，编译器会搜索这些头文件的包含路径。包含路径是通过-I&lt;dir&gt;选项(或环境变量CPATH)指定的。因为头文件的文件名是已知的(例如iostream)。，编译器只需要目录。<br><br>链接器在库路径中搜索将可执行文件所需链接到的库。库路径是通过-Ldir选项(大写’L’后跟目录路径)(或环境变量LIBRARY_PATH)指定的。此外，还必须指定库名。在Unix中，库libxxx.a是通过-lxxx选项(小写字母’l’，没有前缀”lib”和”.so”扩展)。在Windows中，提供全名，如-lxxx.lib。链接器需要知道目录和库的名称。因此，需要指定两个选项。</p>
<h5 id="默认的头文件路径，库路径和库"><a href="#默认的头文件路径，库路径和库" class="headerlink" title="默认的头文件路径，库路径和库"></a>默认的头文件路径，库路径和库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp -v</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>以详细模式(-v)运行编译，学习使用系统中使用的库路径(-L)和库(-L):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br><span class="line">......</span><br><span class="line">-L/usr/lib/gcc/x86_64-pc-cygwin/6.4.0</span><br><span class="line">-L/usr/x86_64-pc-cygwin/lib</span><br><span class="line">-L/usr/lib</span><br><span class="line">-L/lib</span><br><span class="line">-lgcc_s     // libgcc_s.a</span><br><span class="line">-lgcc       // libgcc.a</span><br><span class="line">-lcygwin    // libcygwin.a</span><br><span class="line">-ladvapi32  // libadvapi32.a</span><br><span class="line">-lshell32   // libshell32.a</span><br><span class="line">-luser32    // libuser32.a</span><br><span class="line">-lkernel32  // libkernel32.a</span><br></pre></td></tr></table></figure>

<h3 id="GCC-环境变量"><a href="#GCC-环境变量" class="headerlink" title="GCC 环境变量"></a>GCC 环境变量</h3><p>GCC使用下面这些环境变量:</p>
<ul>
<li>PATH: 用于搜索可执行程序和运行时共享库(.so, .dll)。</li>
<li>CPATH: 用于搜索头文件的包含路径。它在-I<dir>选项中指定的路径被搜索后搜索。如果在预处理中指定了特定的语言，那么<em>C_INCLUDE_PATH</em>和<em>CPLUS_INCLUDE_PATH</em>可以用来指定C和C++头文件。</li>
<li>LIBRARY_PATH: 用于搜索链接库的库路径。。它在-L<dir>选项中指定的路径被搜索后搜索。</li>
</ul>
<h3 id="编译过程实操"><a href="#编译过程实操" class="headerlink" title="编译过程实操"></a>编译过程实操</h3><blockquote>
<p>file #显示文件类型<br></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL(x, y) ((x)*(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	z = add(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, add(x, y));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, MUL(x, y));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash">cpp hello.c &gt; hello.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpp add.c &gt; add.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.i</span></span><br><span class="line">...//此处省略若干行</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 <span class="string">&quot;hello.c&quot;</span></span></span><br><span class="line">int add(int, int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"> int x = 3, y = 4;</span><br><span class="line"> printf(&quot;%d + %d = %d\n&quot;, x, y, add(x, y));</span><br><span class="line"> printf(&quot;%d * %d = %d\n&quot;, x, y, ((x)*(y)));</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#可以看出MUL宏被展开了</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S add.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.s </span></span><br><span class="line">hello.s: assembler source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.s </span></span><br><span class="line">	.file	&quot;hello.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;%d + %d = %d\n&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string	&quot;%d * %d = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">...//此处省略若干行，展开后的源码在这一步被编译成对应平台的汇编代码</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o add.o add.s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.o </span></span><br><span class="line">hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 0000000000400280</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#上面这个警告不会影响程序运行，但是会在return的时候导致段错误</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello</span></span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ./hello </span></span><br><span class="line">3 + 4 = 7</span><br><span class="line">3 * 4 = 12</span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#ld那一步的警告改用gcc命令可以避免&lt;br&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nm   #通常用于检查对象文件中是否定义了特定的函数。”T”表示已定义的函数，”U”表示未定义的函数，应由链接器解析。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nm -C hello.o </span></span><br><span class="line">                 U add      #可以看到目标文件hello.o里没有add函数的定义 </span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U printf</span><br><span class="line"><span class="meta">#</span><span class="bash"> nm add.o </span></span><br><span class="line">0000000000000000 T add      #add的定义在目标文件add.o中</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nm    #用来显示它所需要的共享库的列表。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd hello</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe8c1f0000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3d1b6bd000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f3d1ba87000)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接 <a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>QtVS开发环境配置篇</title>
    <url>/QtVS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="1-Visual-studio-2019-的安装"><a href="#1-Visual-studio-2019-的安装" class="headerlink" title="1. Visual studio 2019 的安装"></a>1. Visual studio 2019 的安装</h1><p>a) 点此<a href="https://visualstudio.microsoft.com/zh-hans/vs/">地址</a>进入 Visual Studio 官网，下载 Community 2019 版(实际下载的为安装器)<br><img src="https://pic.downk.cc/item/5f752469160a154a67f65681.jpg" alt="vs2019社区版"></p>
<a id="more"></a>
<p>b) 安装完后会启动 Visual Studio Installer 安装器，工作负载勾选“使用C++的桌面开发”后直接进行安装即可<br><img src="https://pic.downk.cc/item/5f752c0c160a154a67f7be78.jpg" alt="vs2019安装组件"></p>
<h1 id="2-Qt-5-14-2-的安装"><a href="#2-Qt-5-14-2-的安装" class="headerlink" title="2. Qt 5.14.2 的安装"></a>2. Qt 5.14.2 的安装</h1><p>a) 从此<a href="http://download.qt.io/official_releases/qt/5.14/5.14.2/">镜像站</a>下载会自动选择最近的镜像地址，下载如下版本<br><img src="https://pic.downk.cc/item/5f76d259160a154a6754183f.jpg" alt="image"><br>b) 下载完成后安装，注册登录后一直下一步到此界面，红框内为必勾选项目，完成安装<br><img src="https://pic.downk.cc/item/5f76d497160a154a6754b6f1.jpg" alt="image"></p>
<h1 id="3-Qt-Visual-Studio-Tools-扩展的安装"><a href="#3-Qt-Visual-Studio-Tools-扩展的安装" class="headerlink" title="3. Qt Visual Studio Tools 扩展的安装"></a>3. Qt Visual Studio Tools 扩展的安装</h1><p>a) 安装Qt Visual Studio Tools的方法有两种，一种是源码编译，参考<a href="https://wiki.qt.io/Visual_Studio_Add-in">这里</a>。<br><br>b) 另一种是通过VS自带的插件管理器安装，步骤如下：<br><br>启动VS2019,选择继续但无需代码进入到主界面<br><img src="https://pic.downk.cc/item/5f76d70d160a154a675553fe.jpg" alt="image"><br>c) 从菜单栏依次点击“扩展-&gt;管理扩展”，打开界面后，先点联机，在输入框搜索Qt，点下载Qt Visual Studio Tools，因为众所周知的原因，下载插件的速度较慢，此外还可以通过右边的详细信息拿到下载地址的url，用度盘离线下载，我分享一个已经下载好的，<a href="https://pan.baidu.com/s/1MkwPsNwEyANAAbQeoSJfMw">提取码：7692</a><br><img src="https://pic.downk.cc/item/5f76d933160a154a6755e924.jpg" alt="image"><br>关闭VS2019后,安装下载的插件(通过管理扩展页面下载的插件可以跳过下面的安装过程)，<img src="https://pic.downk.cc/item/5f76db8f160a154a67568e6e.jpg" alt="image"><br>安装完成后再次启动VS2019</p>
<h1 id="4-Qt-Visual-Studio-Tools-插件的配置"><a href="#4-Qt-Visual-Studio-Tools-插件的配置" class="headerlink" title="4. Qt Visual Studio Tools 插件的配置"></a>4. Qt Visual Studio Tools 插件的配置</h1><p>a)  从菜单栏依次点击“扩展-&gt;Qt VS Tools-&gt;Qt Options”，按下图点开扩展中的 Qt Options<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f90.jpg"><br>b) 弹出Qt Options页面后，点击Add按钮弹出以下界面，再点击Path行最右侧的按钮。<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f93.jpg"><br>c) 定位到Qt 5.14.2的安装路径，默认为C:\Qt\Qt5.14.2\5.14.2\msvc2017和C:\Qt\Qt5.14.2\5.14.2\msvc2017_64，添加这两个编译平台，Default配置随意，保存即可完成配置<br><img src="https://pic.downk.cc/item/5f7f26761cd1bbb86bd01d62.jpg"></p>
]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH密钥登录二三事</title>
    <url>/SSH%E7%99%BB%E5%BD%95%E4%BA%8C%E4%B8%89%E4%BA%8B.html</url>
    <content><![CDATA[<p>在日常使用中，除了密码登录更多的是使用密钥方式登录SSH。密钥对分成公钥和私钥，将公钥添加到需要登录的服务器用户的家目录下.ssh/authorized_keys文件中，在ssh登录时使用’-i’参数指定私钥 或 将私钥天骄到Xshell用户密钥中。</p>
<p>使用密钥登录通常需要经过以下步骤：</br></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 客户端软件：Xshell 6</br></li>
<li><input checked="" disabled="" type="checkbox"> 客户端终端：Linux company 4.4.0-18362-Microsoft</br></li>
<li><input checked="" disabled="" type="checkbox"> 服务端版本：OpenSSH_7.9p1 Raspbian-10+deb10u2, OpenSSL 1.1.1d  10 Sep 2019</li>
</ul>
<h3 id="生成登录密钥对"><a href="#生成登录密钥对" class="headerlink" title="生成登录密钥对"></a>生成登录密钥对</h3><ul>
<li>方法一：使用ssh-keygen命令生成密钥对</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t 加密方式 -C 备注</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~$ ssh-keygen -t rsa #加密方式为rsa</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa): &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars #置空使用默认路径和命名</span><br><span class="line">Enter passphrase (empty for no passphrase): #置空表示不为密钥设置密码</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;mars&#x2F;.ssh&#x2F;id_rsa_mars.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Y11r6HcjCAK35&#x2F;6N0ry1e7aEeQoIdhfws1F02YmpNl4 mars@company</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|        .  .o +o.|</span><br><span class="line">|         o . +...|</span><br><span class="line">|    . .   &#x3D; o    |</span><br><span class="line">|     o . . @ E   |</span><br><span class="line">|      &#x3D; S B &#x3D;    |</span><br><span class="line">|     . B * + o   |</span><br><span class="line">|        oo+ * &#x3D;  |</span><br><span class="line">|       .. o* Bo. |</span><br><span class="line">|        .o+.&#x3D;+.. |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line">mars@company:~$ cd .ssh&#x2F; &amp;&amp; ll</span><br><span class="line">total 8.0K</span><br><span class="line">-rw------- 1 mars mars 2.6K Oct 26 15:22 id_rsa_mars #私钥的权限必须为0600</span><br><span class="line">-rw-r--r-- 1 mars mars  566 Oct 26 15:22 id_rsa_mars.pub</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Xshell客户端生成密钥对</li>
</ul>
<p>点击Xshell菜单栏上的”工具”-&gt;”新建用户密钥生成向导”，按下图操作生成和保存密钥对。</br><br>密钥类型默认RSA，长度2048位，名称随意，密码可选，最后把用户密钥也导出来(非必要步骤，保存以备复用)。<br><img src="https://pic.downk.cc/item/5f96728d1cd1bbb86bcbb354.gif" alt="image"></p>
<p><strong>两种方法都可以显式地看到生成文件</strong>：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>id_rsa_mars.pub</td>
<td>公钥(主机密钥)，保存到服务器上，来验证请求登录用户的私钥</td>
</tr>
<tr>
<td>id_rsa_mars</td>
<td>私钥(用户密钥)，SSH登录时指定，提供给服务器进行登录验证</td>
</tr>
</tbody></table>
<h3 id="服务器注册公钥"><a href="#服务器注册公钥" class="headerlink" title="服务器注册公钥"></a>服务器注册公钥</h3><p>需要把公钥添加到要登录的用户家目录下的.ssh路径下的authorized_keys文件中，一个便捷的方式是使用 ssh-copy-id 命令上传公钥，这一步需要登录用户的密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i 公钥路径 登录用户名@登录主机名或ip -p 端口</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh-copy-id -i id_rsa_mars.pub pi@192.168.0.125 -p 22</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;id_rsa_mars.pub&quot;</span><br><span class="line">The authenticity of host &#39;[192.168.0.125]:22 ([192.168.0.125]:22)&#39; can&#39;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:YG43kzBF5jzsbL2yo9Uw&#x2F;negmUvVMyiGACksK5&#x2F;ppUc.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">pi@192.168.0.125&#39;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh -p &#39;22&#39; &#39;pi@192.168.0.125&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line"></span><br><span class="line"># 检查是否上传完成</span><br><span class="line">pi@raspberrypi:~ $ cat .ssh&#x2F;authorized_keys </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1BzYNq7RB5&#x2F;OCXVbPIs6EGj2OjS9ug0mHpdFgWngLFAaC3&#x2F;msX9kvgLvM90mklExljtCXu3mNXiPDJpItWiQJcdKn90leciEtgJQiAa&#x2F;hNbIeurGrN6D9+uCYbNFjzwezTTEghXzeHCC&#x2F;aP+M3M+TbyLSTAdadcSSFQJ8jgYh&#x2F;wYvgeR03tSZrfwoFvkKeiep0z4P1hKz7weMPGpr+GIW3egutx&#x2F;8gXfJ80ZE8ErPUsdasmsyHSNO3SjkDpXXarMkeb8bc6LLrZaxtp4uPw9M7YLcyuiLvUjyHvqM7D4Kh4bDJTXOL5mpVdAXrB3C8a32hMzwzn6REW1o6Yqh8Tl6qw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h3 id="客户端登录时指定私钥"><a href="#客户端登录时指定私钥" class="headerlink" title="客户端登录时指定私钥"></a>客户端登录时指定私钥</h3><ul>
<li>方法一：使用ssh命令指定私钥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i 私钥路径 登录用户名@登录主机名或ip -p 端口</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh -i id_rsa_mars pi@192.168.0.125 -p 21414</span><br><span class="line">Linux raspberrypi 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU&#x2F;Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU&#x2F;Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Mon Oct 26 16:17:34 2020 from 192.168.137.1</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Xshell指定用户密钥</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f9688021cd1bbb86bd16d11.jpg" alt="image"></p>
<h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>1.权限问题，改为0600即可解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mars@company:~&#x2F;.ssh$ ssh -i id_rsa_mars -p 21414 &#39;pi@103.46.128.21&#39;</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0777 for &#39;id_rsa_mars&#39; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;id_rsa_mars&quot;: bad permissions</span><br><span class="line">pi@103.46.128.21&#39;s password:</span><br><span class="line"></span><br><span class="line">mars@company:~&#x2F;.ssh$ chmod 0600 id_rsa_mars   #修改私钥权限为0600</span><br></pre></td></tr></table></figure>

<p>2.ssh -i指定密钥登录仍需要输入密码，Xshell提示<strong>所选的用户密钥未在远程主机上注册</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原因是公钥(主机密钥)没有添加成功，重新添加后即可解决</span><br></pre></td></tr></table></figure>

<h3 id="ssh命令备忘"><a href="#ssh命令备忘" class="headerlink" title="ssh命令备忘"></a>ssh命令备忘</h3><ul>
<li><p>从某主机的80端口开启到本地主机2001端口的隧道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -N -L2001:localhost:80 somemachine</span><br></pre></td></tr></table></figure>
<p>现在你可以直接在浏览器中输入<a href="http://localhost:2001访问这个网站。">http://localhost:2001访问这个网站。</a></p>
</li>
<li><p>直接连接到只能通过主机B连接的主机A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -t hostA ssh hostB</span><br></pre></td></tr></table></figure>
<p>当然，你要能访问主机A才行。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
