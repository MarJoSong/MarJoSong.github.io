<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++内存布局</title>
    <url>/C-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<h3 id="1-内存分布图"><a href="#1-内存分布图" class="headerlink" title="1. 内存分布图"></a>1. 内存分布图</h3><p><img src="https://pic.imgdb.cn/item/5f729e85160a154a675a2493.png" alt="Memory Sort Map"></p>
<a id="more"></a>
<p><font color=green size=4>1. Stack段：局部变量存放区域。</font><br><font color=green size=4>2. heap段：用户动态分配内存区域。</font><br><font color=green size=4>3. bss段：存放未初始化的全局或静态变量内存区域。(Block Started by Symbol)</font><br><font color=green size=4>4. 数据段：通常指存放已初始化的全局变量的内存区域。(data segment)</font><br><font color=green size=4>5. 代码段：通常指存放程序执行代码的一块内存区域。(code segment/text segment)</font></p>
<blockquote>
<p>C规定，未初始化变量的初值为0，这个清0的操作是由<strong>启动代码</strong>完成的，还有已初始化变量的初值的设置，也是由<strong>启动代码</strong>完成的。<br>为了启动代码的简单化，编译链接器会把已初始化的变量放在同一个段：.data，这个段的映像（包含了各个变量的初值）保存在“只读数据段”，这样启动代码就可以简单地复制这个映像到 .data 段，所有的已初始化变量就都初始化了。<br>而未初始化变量也放在同一个段：.bss，启动代码简单地调用 memset 就可以把所有未初始化变量都清0。</p>
</blockquote>
<hr>
<h3 id="2-在C中分为5个存储区"><a href="#2-在C中分为5个存储区" class="headerlink" title="2. 在C中分为5个存储区"></a>2. 在C中分为5个存储区</h3><p><font color=green size=4>1. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似数据结构中的栈。</font><br><font color=green size=4>2. 堆区:一般由程序员分配和释放(malloc,alloc,realloc,free)，程序结束时内存空间由系统回收，与数据结构的堆毫无关系。</font><br><font color=green size=4>3. 全局/静态区：全局变量和静态变量的存储是在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</font><br><font color=green size=4>4. 文字常量区：常量和字符串就是存放在这里，程序结束后由系统释放。</font><br><font color=green size=4>5. 程序代码区：存放函数体的二进制代码。</font></p>
<blockquote>
<p>所有函数体外定义的变量就是全局变量，加了static修饰符后不管在哪里都存放在全局（静态区），全局的static变量只对该文件中有效，不能extern到别的文件用，在函数体内部定义的static表示在该函数体内有效。另外，函数体中的这样的字符串字面量存放在常量区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span>* p ;<span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//s在栈，abc在字符常量区</span></span><br><span class="line">	<span class="keyword">char</span> *p2 ;<span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p3 = <span class="string">&quot;abcdef&quot;</span><span class="comment">//p3栈，abcdef在字符常量区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">	p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//在堆上开辟10个字节的内存，p1本身在栈中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-C-C-中堆区和自由存储区的区别与联系"><a href="#3-C-C-中堆区和自由存储区的区别与联系" class="headerlink" title="3. C/C++中堆区和自由存储区的区别与联系"></a>3. C/C++中堆区和自由存储区的区别与联系</h3><p><font color=green size=4>1. malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放。</font><br><font color=green size=4>2. 堆(heap)是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存释放。自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，即缺省的全局运算符new和delete会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</font></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译过程</title>
    <url>/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h3 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h3><hr>
<p><img src="https://pic.imgdb.cn/item/5f73f793160a154a67b421a5.jpg" alt="C程序编译过程"></p>
<a id="more"></a>
<p>GCC编译一个C/C++ 程序到可执行程序可分成以上4个步骤。例如，”gcc-o hello.exe hello.c”执行如下:</p>
<h6 id="1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。"><a href="#1-预处理-预处理器-cpp-来展开包含的头文件-include-和宏定义-define-。" class="headerlink" title="1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。"></a>1. 预处理: 预处理器(cpp)来展开包含的头文件(#include)和宏定义(#define)。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp hello.c &gt; hello.i</span></span><br></pre></td></tr></table></figure>
<p>生成的文件”hello.i”包含了展开扩展后的源码。</p>
<h6 id="2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。"><a href="#2-编译-编译器将预处理的源代码编译成特定程序集的汇编代码。" class="headerlink" title="2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。"></a>2. 编译: 编译器将预处理的源代码编译成特定程序集的汇编代码。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i</span></span><br></pre></td></tr></table></figure>
<p>选项 -S 指定生成汇编代码，而不是目标代码。生成的汇编文件为”hello.s”。</p>
<h6 id="3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。"><a href="#3-汇编-汇编器-as-将汇编代码转换为目标文件中的机器代码”hello-o”。" class="headerlink" title="3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。"></a>3. 汇编: 汇编器(as)将汇编代码转换为目标文件中的机器代码”hello.o”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s</span></span><br></pre></td></tr></table></figure>

<h6 id="4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。"><a href="#4-链接器-链接器-ld-将目标代码与库代码链接起来，生成可执行文件”hello-exe”。" class="headerlink" title="4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。"></a>4. 链接器: 链接器(ld)将目标代码与库代码链接起来，生成可执行文件”hello.exe”。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello.exe hello.o ...libraries...</span></span><br></pre></td></tr></table></figure>

<p>Verbose Mode (-v)<br>可以通过启用-v (verbose)选项查看详细的编译过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br></pre></td></tr></table></figure>

<p>Defining Macro (-D)<br>可以使用-Dname选项定义宏，或者使用-Dname=value定义带有值的宏。如果值包含空格，则应该用双引号括起来。</p>
<h3 id="头文件-h-，静态库-a-lib-和动态库-so-dll"><a href="#头文件-h-，静态库-a-lib-和动态库-so-dll" class="headerlink" title="头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)"></a>头文件(.h)，静态库(.a, .lib)和动态库(.so, .dll)</h3><hr>
<h5 id="静态库-VS-动态库"><a href="#静态库-VS-动态库" class="headerlink" title="静态库 VS 动态库"></a>静态库 VS 动态库</h5><p>库是可以通过链接器链接到程序中的预编译过的目标文件的集合，例如系统函数printf()和sqrt()。<br><br>外部库有两种类型:静态库和共享库。<br></p>
<ol>
<li>静态库的文件扩展名在Unix中为”.a”(归档文件)在Windows中为”.lib”。当链接静态库到程序时，程序中使用的外部函数的机器码将复制到可执行文件中。静态库可以通过”ar”存档程序创建。<br></li>
<li>共享库的文件扩展名在Unix中为”.lib”(共享对象)在Windows中为”dll”(动态链接库)。当链接共享库到程序时，只会在可执行文件中创建一个小表。在可执行文件开始运行之前，操作系统加载外部函数所需的机器码——这个过程称为动态链接。动态链接使可执行文件更小并节省磁盘空间，因为库的一个副本可以在多个程序之间共享。此外，大多数操作系统允许内存中共享库的一个副本被所有正在运行的程序使用，从而节省内存。可以升级共享库代码，而不需要重新编译程序。</li>
</ol>
<p>由于动态链接的优点，默认情况下，如果共享库可用，GCC会链接到共享库。<br><br>您可以通过 <font color=red>nm file</font> 列出库的内容。</p>
<h5 id="搜索头文件和库-I-L-and-l"><a href="#搜索头文件和库-I-L-and-l" class="headerlink" title="搜索头文件和库(-I, -L and -l)"></a>搜索头文件和库(-I, -L and -l)</h5><p>在编译程序时，编译器需要头文件来编译源代码;链接器需要这些库来解析来自其他对象文件或库的外部引用。除非您设置了适当的选项，否则编译器和链接器将无法找到头文件/库。<br><br>对于源代码中使用的每个头文件(通过#include指令)，编译器会搜索这些头文件的包含路径。包含路径是通过-I&lt;dir&gt;选项(或环境变量CPATH)指定的。因为头文件的文件名是已知的(例如iostream)。，编译器只需要目录。<br><br>链接器在库路径中搜索将可执行文件所需链接到的库。库路径是通过-Ldir选项(大写’L’后跟目录路径)(或环境变量LIBRARY_PATH)指定的。此外，还必须指定库名。在Unix中，库libxxx.a是通过-lxxx选项(小写字母’l’，没有前缀”lib”和”.so”扩展)。在Windows中，提供全名，如-lxxx.lib。链接器需要知道目录和库的名称。因此，需要指定两个选项。</p>
<h5 id="默认的头文件路径，库路径和库"><a href="#默认的头文件路径，库路径和库" class="headerlink" title="默认的头文件路径，库路径和库"></a>默认的头文件路径，库路径和库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cpp -v</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>以详细模式(-v)运行编译，学习使用系统中使用的库路径(-L)和库(-L):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -v -o hello.exe hello.c</span></span><br><span class="line">......</span><br><span class="line">-L/usr/lib/gcc/x86_64-pc-cygwin/6.4.0</span><br><span class="line">-L/usr/x86_64-pc-cygwin/lib</span><br><span class="line">-L/usr/lib</span><br><span class="line">-L/lib</span><br><span class="line">-lgcc_s     // libgcc_s.a</span><br><span class="line">-lgcc       // libgcc.a</span><br><span class="line">-lcygwin    // libcygwin.a</span><br><span class="line">-ladvapi32  // libadvapi32.a</span><br><span class="line">-lshell32   // libshell32.a</span><br><span class="line">-luser32    // libuser32.a</span><br><span class="line">-lkernel32  // libkernel32.a</span><br></pre></td></tr></table></figure>

<h3 id="GCC-环境变量"><a href="#GCC-环境变量" class="headerlink" title="GCC 环境变量"></a>GCC 环境变量</h3><p>GCC使用下面这些环境变量:</p>
<ul>
<li>PATH: 用于搜索可执行程序和运行时共享库(.so, .dll)。</li>
<li>CPATH: 用于搜索头文件的包含路径。它在-I<dir>选项中指定的路径被搜索后搜索。如果在预处理中指定了特定的语言，那么<em>C_INCLUDE_PATH</em>和<em>CPLUS_INCLUDE_PATH</em>可以用来指定C和C++头文件。</li>
<li>LIBRARY_PATH: 用于搜索链接库的库路径。。它在-L<dir>选项中指定的路径被搜索后搜索。</li>
</ul>
<h3 id="编译过程实操"><a href="#编译过程实操" class="headerlink" title="编译过程实操"></a>编译过程实操</h3><blockquote>
<p>file #显示文件类型<br></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL(x, y) ((x)*(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	z = add(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, add(x, y));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, MUL(x, y));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash">cpp hello.c &gt; hello.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpp add.c &gt; add.i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.c </span></span><br><span class="line">hello.c: C source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.i</span></span><br><span class="line">...//此处省略若干行</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 <span class="string">&quot;hello.c&quot;</span></span></span><br><span class="line">int add(int, int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"> int x = 3, y = 4;</span><br><span class="line"> printf(&quot;%d + %d = %d\n&quot;, x, y, add(x, y));</span><br><span class="line"> printf(&quot;%d * %d = %d\n&quot;, x, y, ((x)*(y)));</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#可以看出MUL宏被展开了</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S hello.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -S add.i </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.s </span></span><br><span class="line">hello.s: assembler source, ASCII text</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat hello.s </span></span><br><span class="line">	.file	&quot;hello.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;%d + %d = %d\n&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string	&quot;%d * %d = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">...//此处省略若干行，展开后的源码在这一步被编译成对应平台的汇编代码</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o hello.o hello.s </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as -o add.o add.s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello.o </span></span><br><span class="line">hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ld -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 0000000000400280</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#上面这个警告不会影响程序运行，但是会在return的时候导致段错误</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file hello</span></span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, not stripped</span><br><span class="line"><span class="meta">#</span><span class="bash"> ./hello </span></span><br><span class="line">3 + 4 = 7</span><br><span class="line">3 * 4 = 12</span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#ld那一步的警告改用gcc命令可以避免&lt;br&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -o hello hello.o add.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nm   #通常用于检查对象文件中是否定义了特定的函数。”T”表示已定义的函数，”U”表示未定义的函数，应由链接器解析。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nm -C hello.o </span></span><br><span class="line">                 U add      #可以看到目标文件hello.o里没有add函数的定义 </span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U printf</span><br><span class="line"><span class="meta">#</span><span class="bash"> nm add.o </span></span><br><span class="line">0000000000000000 T add      #add的定义在目标文件add.o中</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nm    #用来显示它所需要的共享库的列表。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd hello</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe8c1f0000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3d1b6bd000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f3d1ba87000)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接 <a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>QtVS开发环境配置篇</title>
    <url>/QtVS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="1-Visual-studio-2019-的安装"><a href="#1-Visual-studio-2019-的安装" class="headerlink" title="1. Visual studio 2019 的安装"></a>1. Visual studio 2019 的安装</h1><p>a) 点此<a href="https://visualstudio.microsoft.com/zh-hans/vs/">地址</a>进入 Visual Studio 官网，下载 Community 2019 版(实际下载的为安装器)</p>
<a id="more"></a>
<p><img src="https://pic.downk.cc/item/5f752469160a154a67f65681.jpg" alt="vs2019社区版"><br>b) 安装完后会启动 Visual Studio Installer 安装器，工作负载勾选“使用C++的桌面开发”后直接进行安装即可<br><img src="https://pic.downk.cc/item/5f752c0c160a154a67f7be78.jpg" alt="vs2019安装组件"></p>
<h1 id="2-Qt-5-14-2-的安装"><a href="#2-Qt-5-14-2-的安装" class="headerlink" title="2. Qt 5.14.2 的安装"></a>2. Qt 5.14.2 的安装</h1><p>a) 从此<a href="http://download.qt.io/official_releases/qt/5.14/5.14.2/">镜像站</a>下载会自动选择最近的镜像地址，下载如下版本<br><img src="https://pic.downk.cc/item/5f76d259160a154a6754183f.jpg" alt="image"><br>b) 下载完成后安装，注册登录后一直下一步到此界面，红框内为必勾选项目，完成安装<br><img src="https://pic.downk.cc/item/5f76d497160a154a6754b6f1.jpg" alt="image"></p>
<h1 id="3-Qt-Visual-Studio-Tools-扩展的安装"><a href="#3-Qt-Visual-Studio-Tools-扩展的安装" class="headerlink" title="3. Qt Visual Studio Tools 扩展的安装"></a>3. Qt Visual Studio Tools 扩展的安装</h1><p>a) 安装Qt Visual Studio Tools的方法有两种，一种是源码编译，参考<a href="https://wiki.qt.io/Visual_Studio_Add-in">这里</a>。<br><br>b) 另一种是通过VS自带的插件管理器安装，步骤如下：<br><br>启动VS2019,选择继续但无需代码进入到主界面<br><img src="https://pic.downk.cc/item/5f76d70d160a154a675553fe.jpg" alt="image"><br>c) 从菜单栏依次点击“扩展-&gt;管理扩展”，打开界面后，先点联机，在输入框搜索Qt，点下载Qt Visual Studio Tools，因为众所周知的原因，下载插件的速度较慢，此外还可以通过右边的详细信息拿到下载地址的url，用度盘离线下载，我分享一个已经下载好的，<a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1MkwPsNwEyANAAbQeoSJfMw">提取码：7692</a><br><img src="https://pic.downk.cc/item/5f76d933160a154a6755e924.jpg" alt="image"><br>关闭VS2019后,安装下载的插件(通过管理扩展页面下载的插件可以跳过下面的安装过程)，<img src="https://pic.downk.cc/item/5f76db8f160a154a67568e6e.jpg" alt="image"><br>安装完成后再次启动VS2019</p>
<h1 id="4-Qt-Visual-Studio-Tools-插件的配置"><a href="#4-Qt-Visual-Studio-Tools-插件的配置" class="headerlink" title="4. Qt Visual Studio Tools 插件的配置"></a>4. Qt Visual Studio Tools 插件的配置</h1><p>a)  从菜单栏依次点击“扩展-&gt;Qt VS Tools-&gt;Qt Options”，按下图点开扩展中的 Qt Options<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f90.jpg"><br>b) 弹出Qt Options页面后，点击Add按钮弹出以下界面，再点击Path行最右侧的按钮。<br><img src="https://pic.downk.cc/item/5f76dd6a160a154a67570f93.jpg"><br>c) 定位到Qt 5.14.2的安装路径，默认为C:\Qt\Qt5.14.2\5.14.2\msvc2017和C:\Qt\Qt5.14.2\5.14.2\msvc2017_64，添加这两个编译平台，Default配置随意，保存即可完成配置<br><img src="https://pic.downk.cc/item/5f7f26761cd1bbb86bd01d62.jpg"></p>
]]></content>
      <tags>
        <tag>Qt, VS</tag>
      </tags>
  </entry>
</search>
